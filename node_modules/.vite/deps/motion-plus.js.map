{
  "version": 3,
  "sources": ["../../motion-plus-dom/dist/es/split-text/index.mjs"],
  "sourcesContent": ["import { resolveElements } from 'motion-dom';\nimport { invariant } from 'motion-utils';\n\nfunction createSpan(className, index) {\n    const span = document.createElement(\"span\");\n    if (className) {\n        span.className = className;\n    }\n    if (index !== undefined) {\n        span.dataset.index = index.toString();\n    }\n    span.style.display = \"inline-block\";\n    return span;\n}\nfunction addToken(element, token, className, index) {\n    const charSpan = createSpan(className, index);\n    charSpan.textContent = token;\n    element.appendChild(charSpan);\n    return charSpan;\n}\n/**\n * Splits text content of an element into characters, words, and lines.\n *\n * @param elementOrSelector - The element or selector of the element to split. If multiple elements are found, only the first will be split.\n * @param options - Options.\n * @returns An object the chars, words, and lines DOM nodes as a list.\n */\nfunction splitText(elementOrSelector, { splitBy = \" \", charClass = \"split-char\", wordClass = \"split-word\", lineClass = \"split-line\", } = {}) {\n    /**\n     * We currently only support splitting a single element.\n     * This could be changed in a future version.\n     */\n    const [element] = resolveElements(elementOrSelector);\n    invariant(Boolean(element), \"Element not found\");\n    const text = element.textContent || \"\";\n    element.setAttribute(\"aria-label\", text);\n    element.textContent = \"\";\n    /**\n     * Keep lists of split elements.\n     */\n    const splitElements = {\n        chars: [],\n        words: [],\n        lines: [],\n    };\n    /**\n     * Split the text into words using the provided delimiter.\n     */\n    const words = text.split(splitBy);\n    const wordElements = [];\n    const spacerElements = [];\n    /**\n     * Write: Create all word and character spans before measuring top offsets.\n     */\n    for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {\n        const word = words[wordIndex];\n        const wordSpan = createSpan(wordClass, wordIndex);\n        splitElements.words.push(wordSpan);\n        wordElements.push(wordSpan);\n        /**\n         * Create a span for each character in the word.\n         */\n        const chars = Array.from(word);\n        for (let charIndex = 0; charIndex < chars.length; charIndex++) {\n            const char = chars[charIndex];\n            const charSpan = addToken(wordSpan, char, charClass, charIndex);\n            splitElements.chars.push(charSpan);\n        }\n        /**\n         * Add the word span to the parent element.\n         */\n        element.appendChild(wordSpan);\n        /**\n         * Add the delimiter after the word. If the delimiter is a space,\n         * add a space text node directly to the parent element, otherwise\n         * add the delimited as a character to allow it to be animated.\n         */\n        if (wordIndex < words.length - 1) {\n            if (splitBy === \" \") {\n                const spaceNode = document.createTextNode(\" \");\n                element.appendChild(spaceNode);\n                spacerElements.push(spaceNode);\n            }\n            else {\n                const delimiterSpan = addToken(wordSpan, splitBy, `${charClass}-delimiter`);\n                splitElements.chars.push(delimiterSpan);\n            }\n        }\n    }\n    // TODO: Would it be worth allowing early return without line splitting?\n    /**\n     * Read: Measure the top offset of each word.\n     */\n    const wordData = wordElements.map((wordSpan, index) => {\n        return {\n            element: wordSpan,\n            top: wordSpan.offsetTop,\n            index,\n            spacer: index < spacerElements.length ? spacerElements[index] : null,\n        };\n    });\n    /**\n     * Write: Group words into lines based on measured top offsets.\n     */\n    const lines = [];\n    let currentLine = [];\n    let currentTop = wordData[0]?.top ?? 0;\n    let lineIndex = 0;\n    for (let i = 0; i < wordData.length; i++) {\n        const { element, top, spacer } = wordData[i];\n        // Check if word starts a new line\n        if (top > currentTop && currentLine.length > 0) {\n            // Complete current line and start a new one\n            lines.push({ elements: currentLine, lineIndex: lineIndex++ });\n            currentLine = [];\n            currentTop = top;\n        }\n        // Add word to current line\n        currentLine.push(element);\n        // Add spacer if it exists\n        if (spacer) {\n            currentLine.push(spacer);\n        }\n    }\n    // Add the last line if it has any elements\n    if (currentLine.length > 0) {\n        lines.push({ elements: currentLine, lineIndex });\n    }\n    /**\n     * Write: Rebuild element with lines.\n     */\n    element.textContent = \"\";\n    for (const { elements, lineIndex } of lines) {\n        const lineSpan = createSpan(lineClass, lineIndex);\n        lineSpan.style.display = \"inline-block\";\n        splitElements.lines.push(lineSpan);\n        // Build the line with the word elements.\n        for (const node of elements) {\n            lineSpan.appendChild(node);\n        }\n        element.appendChild(lineSpan);\n    }\n    return splitElements;\n}\n\nexport { splitText };\n"],
  "mappings": "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",
  "names": ["element", "lineIndex"]
}
