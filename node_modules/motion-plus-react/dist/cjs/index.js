'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('motion/react');
var React = require('react');
var reactDom = require('react-dom');
var motionUtils = require('motion-utils');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const DEFAULT_SIZE = 16;
const POINTER_SIZE = 30;
const TEXT_WIDTH = 4;
const TEXT_HEIGHT = 20;
function getCursorSize(type, state, { matchPointerSize, matchTextSize, }) {
    switch (type) {
        case "pointer":
            if (matchPointerSize && state.targetBoundingBox) {
                return state.targetBoundingBox;
            }
            return { width: POINTER_SIZE, height: POINTER_SIZE };
        case "text":
            if (matchTextSize && state.fontSize) {
                return { width: TEXT_WIDTH, height: state.fontSize };
            }
            return { width: TEXT_WIDTH, height: TEXT_HEIGHT };
        default:
            return { width: DEFAULT_SIZE, height: DEFAULT_SIZE };
    }
}

function useBodyPortal(children) {
    const [hostElement, setHostElement] = React.useState(null);
    React.useLayoutEffect(() => {
        setHostElement(document.body);
    }, []);
    return hostElement ? reactDom.createPortal(children, hostElement) : null;
}

let listener$1 = null;
function startInViewListener() {
    const listeners = new Set();
    function showCursor() {
        listeners.forEach((listener) => listener.show());
    }
    function hideCursor() {
        listeners.forEach((listener) => listener.hide());
    }
    function addEventListeners() {
        document.body.addEventListener("mouseenter", showCursor);
        document.body.addEventListener("mouseleave", hideCursor);
    }
    function removeEventListeners() {
        document.body.removeEventListener("mouseenter", showCursor);
        document.body.removeEventListener("mouseleave", hideCursor);
    }
    return {
        on: (callbacks) => {
            if (!listeners.size) {
                addEventListeners();
            }
            listeners.add(callbacks);
            return () => {
                listeners.delete(callbacks);
                if (listeners.size === 0) {
                    removeEventListeners();
                }
            };
        },
    };
}
function getInViewListener() {
    if (!listener$1) {
        listener$1 = startInViewListener();
    }
    return listener$1;
}
function useCursorIsInView(resetSpring) {
    const [isVisible, setIsVisible] = React.useState(true);
    React.useEffect(() => {
        return getInViewListener().on({
            show: () => {
                if (isVisible)
                    return;
                resetSpring();
                setIsVisible(true);
            },
            hide: () => setIsVisible(false),
        });
    }, [isVisible]);
    return isVisible;
}

function onlyMouse(callback) {
    return (event) => {
        if (event.pointerType === "mouse") {
            callback(event);
        }
    };
}
function onlyLeftClicks(callback) {
    return onlyMouse((event) => {
        if (event.button === 0) {
            callback(event);
        }
    });
}

function findCustomTarget(target) {
    return target.closest("[data-cursor]");
}
function findPointerTarget(element) {
    return element.closest('a, button, input[type="button"]:not(:disabled)');
}
function findTextTarget(element) {
    if (window.getComputedStyle(element).userSelect === "none")
        return null;
    return element.closest("p, textarea:not(:disabled), input[type='text']:not(:disabled), h1, h2, h3, h4, h5, h6");
}
function findTarget(eventTarget) {
    let target = findCustomTarget(eventTarget);
    if (target)
        return [target.dataset.cursor, target];
    target = findPointerTarget(eventTarget);
    if (target)
        return ["pointer", target];
    target = findTextTarget(eventTarget);
    if (target)
        return ["text", target];
    return ["default", null];
}

let listener = null;
let state = {
    type: "default",
    isPressed: false,
    fontSize: null,
    targetBoundingBox: null,
};
function startPointerOverListener() {
    const listeners = new Set();
    function updateState(newState) {
        state = { ...state, ...newState };
        listeners.forEach((listener) => listener(state));
    }
    const handlePointerDown = onlyLeftClicks(() => {
        if (!state.isPressed) {
            updateState({ isPressed: true });
        }
    });
    const handlePointerUp = onlyLeftClicks(() => {
        if (state.isPressed) {
            updateState({ isPressed: false });
        }
    });
    const handlePointerOver = onlyMouse(({ target }) => {
        if (!target)
            return;
        const [type, cursorTarget] = findTarget(target);
        let hasUpdated = false;
        let newState = {};
        if (type !== state.type) {
            newState.type = type;
            hasUpdated = true;
        }
        const size = type === "pointer" && cursorTarget
            ? cursorTarget.getBoundingClientRect()
            : null;
        if (size !== state.targetBoundingBox) {
            newState.targetBoundingBox = size;
            hasUpdated = true;
        }
        if (type === "text") {
            const { fontSize: computedFontSize } = window.getComputedStyle(target);
            const newFontSize = computedFontSize
                ? parseInt(computedFontSize)
                : null;
            if (newFontSize !== state.fontSize) {
                newState.fontSize = newFontSize;
                hasUpdated = true;
            }
        }
        else {
            if (state.fontSize) {
                newState.fontSize = null;
                hasUpdated = true;
            }
        }
        if (hasUpdated) {
            updateState(newState);
        }
    });
    function addEventListeners() {
        window.addEventListener("pointerover", handlePointerOver);
        window.addEventListener("pointerdown", handlePointerDown);
        window.addEventListener("pointerup", handlePointerUp);
    }
    function removeEventListeners() {
        window.removeEventListener("pointerover", handlePointerOver);
        window.removeEventListener("pointerdown", handlePointerDown);
        window.removeEventListener("pointerup", handlePointerUp);
    }
    return {
        onChange: (callback) => {
            if (!listeners.size) {
                addEventListeners();
            }
            listeners.add(callback);
            return () => {
                listeners.delete(callback);
                if (!listeners.size) {
                    removeEventListeners();
                }
            };
        },
    };
}
function getPointerOverListener() {
    if (!listener) {
        listener = startPointerOverListener();
    }
    return listener;
}
function useCursorState() {
    const [latestState, setLatestState] = React.useState({ ...state });
    React.useEffect(() => {
        return getPointerOverListener().onChange((newState) => {
            setLatestState(newState);
        });
    }, [latestState]);
    return latestState;
}

function useHasPointerMoved({ x, y, }, resetSpring) {
    const [pointerHasMoved, setPointerHasMoved] = React.useState(x.prev !== undefined || y.prev !== undefined);
    React.useInsertionEffect(() => {
        if (pointerHasMoved)
            return;
        const setHasMoved = () => {
            setPointerHasMoved(true);
            resetSpring();
            stop();
        };
        const stop = react.pipe(x.on("change", setHasMoved), y.on("change", setHasMoved));
        return () => stop();
    }, [x, y, pointerHasMoved]);
    return pointerHasMoved;
}

function useOffset(position, offset) {
    return {
        x: react.useTransform(() => position.x.get() + offset.x),
        y: react.useTransform(() => position.y.get() + offset.y),
    };
}

let x;
let y;
function initPointerTracking() {
    x = react.motionValue(0);
    y = react.motionValue(0);
    // Cached pointer
    let pointerX = 0;
    let pointerY = 0;
    function updatePointer() {
        x.set(pointerX);
        y.set(pointerY);
    }
    if (typeof window !== "undefined") {
        window.addEventListener("pointermove", onlyMouse((event) => {
            pointerX = event.clientX;
            pointerY = event.clientY;
            /**
             * Don't update pointer until the next render frame to
             * avoid
             *
             * TODO: Update motion values to cache rendered value
             * and use that in projection measurements
             * instead of using this approach
             */
            react.frame.update(updatePointer);
        }));
    }
}
function usePointerPosition() {
    if (!x)
        initPointerTracking();
    return { x: x, y: y };
}

function useMixed(a, b, p) {
    return react.useTransform(() => react.mix(a.get(), b.get(), p.get()));
}

function useSnapToTarget(pointer, isEnabled, state) {
    const crossfade = react.useMotionValue(0);
    const targetCenterX = react.useMotionValue(0);
    const targetCenterY = react.useMotionValue(0);
    const x = useMixed(pointer.x, targetCenterX, crossfade);
    const y = useMixed(pointer.y, targetCenterY, crossfade);
    React.useEffect(() => {
        if (!isEnabled)
            return;
        if (state.targetBoundingBox) {
            targetCenterX.set(state.targetBoundingBox.left + state.targetBoundingBox.width / 2);
            targetCenterY.set(state.targetBoundingBox.top + state.targetBoundingBox.height / 2);
        }
        const animation = react.animate(crossfade, state.targetBoundingBox ? 0.9 : 0);
        return () => animation.stop();
    }, [state.targetBoundingBox, isEnabled]);
    return { x, y };
}

function makeStyles() {
    const style = document.createElement("style");
    style.textContent = `
      * {
          cursor: none !important;
      }
          
      [data-motion-cursor="pointer"] {
          background-color: #333;
      }
    `;
    document.head.appendChild(style);
    return () => {
        document.head.removeChild(style);
    };
}
function useCursorStyles(isCursor) {
    React.useInsertionEffect(isCursor ? makeStyles : motionUtils.noop, [
        isCursor,
    ]);
}

const topLeftPoint = { x: 0, y: 0 };
const centerPoint = { x: 0.5, y: 0.5 };
const skipTransition = { duration: 0 };
const autoSize = { width: "auto", height: "auto" };
const defaultFollowSpring = { stiffness: 1000, damping: 100 };
function Cursor({ follow = false, center = follow ? topLeftPoint : centerPoint, offset: offsetPoint = topLeftPoint, spring = follow ? defaultFollowSpring : false, snapToTarget = false, matchTextSize = true, children, ...props }) {
    const shouldReduceMotion = react.useReducedMotion();
    useCursorStyles(!shouldReduceMotion && !follow);
    const position = usePointerPosition();
    const offset = useOffset(position, offsetPoint);
    const springX = react.useSpring(offset.x, spring || undefined);
    const springY = react.useSpring(offset.y, spring || undefined);
    const resetSpring = () => {
        const removeX = offset.x.on("change", (v) => {
            springX.jump(v);
            removeX();
        });
        const removeY = offset.y.on("change", (v) => {
            springY.jump(v);
            removeY();
        });
    };
    const state = useCursorState();
    const isInView = useCursorIsInView(resetSpring);
    const { x, y } = useSnapToTarget(spring ? { x: springX, y: springY } : position, snapToTarget, state);
    const { width, height } = children
        ? autoSize
        : getCursorSize(state.type, state, {
            matchPointerSize: snapToTarget,
            matchTextSize,
        });
    // TODO: Set center to 0.5 if state.targetBoundingBox && snapToTarget
    const pointerHasMoved = useHasPointerMoved(position, resetSpring);
    return useBodyPortal(pointerHasMoved ? (jsxRuntime.jsx(react.LayoutGroup, { children: jsxRuntime.jsx(react.MotionConfig, { transition: shouldReduceMotion
                ? skipTransition
                : props.transition || defaultTransition, children: jsxRuntime.jsx(react.motion.div, { layout: true, "data-motion-cursor": follow ? "follow" : "pointer", "data-framer-portal-id": "motion-cursor", initial: "exit", exit: "exit", ...props, variants: {
                    default: { opacity: 1, scale: 1 },
                    exit: { opacity: 0, scale: 0 },
                    pressed: follow ? {} : { scale: 0.9 },
                    ...props.variants,
                }, animate: [
                    "default",
                    state.type,
                    !isInView
                        ? "exit"
                        : state.isPressed
                            ? "pressed"
                            : "",
                ], transformTemplate: positionTransform(center), style: {
                    width,
                    height,
                    borderRadius: follow ? 0 : 20,
                    zIndex: follow ? 99998 : 99999,
                    willChange: "transform",
                    contain: "layout",
                    overflow: "hidden",
                    originX: center.x,
                    originY: center.y,
                    ...props.style,
                    x,
                    y,
                    top: 0,
                    left: 0,
                    position: "fixed",
                    pointerEvents: "none",
                }, children: jsxRuntime.jsx(react.AnimatePresence, { children: children }) }) }) })) : null);
}
function positionTransform(origin) {
    return (_, generated) => `translate(-${origin.x * 100}%, -${origin.y * 100}%) ${generated}`;
}
const defaultTransition = { duration: 0.15, ease: [0.38, 0.12, 0.29, 1] };

// Build the mask for the numbers. Technique taken from:
// https://expensive.toys/blog/blur-vignette
const maskHeight = "var(--mask-height, 0.15em)";
const maskWidth = "var(--mask-width, 0.5em)";
const correctedMaskWidth = `calc(${maskWidth} / var(--invert-x, 1))`;
const cornerGradient = `#000 0, transparent 71%`; // or transparent ${maskWidth}
const mask = 
// Horizontal:
`linear-gradient(to right, transparent 0, #000 ${correctedMaskWidth}, #000 calc(100% - ${correctedMaskWidth}), transparent),` +
    // Vertical:
    `linear-gradient(to bottom, transparent 0, #000 ${maskHeight}, #000 calc(100% - ${maskHeight}), transparent 100%),` +
    // TL corner
    `radial-gradient(at bottom right, ${cornerGradient}),` +
    // TR corner
    `radial-gradient(at bottom left, ${cornerGradient}), ` +
    // BR corner
    `radial-gradient(at top left, ${cornerGradient}), ` +
    // BL corner
    `radial-gradient(at top right, ${cornerGradient})`;
const maskSize = `100% calc(100% - ${maskHeight} * 2),` +
    `calc(100% - ${correctedMaskWidth} * 2) 100%,` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight}`;
react.addScaleCorrector({
    "--invert-x": {
        correct: (_, { treeScale, projectionDelta }) => projectionDelta.x.scale * treeScale.x,
    },
});
function Mask({ children, layoutDependency, }) {
    return (jsxRuntime.jsx(react.motion.span, { layout: true, layoutDependency: layoutDependency, "aria-hidden": true, style: {
            display: "inline-flex",
            // Activates the scale correction, which gets stored in --invert-xion
            "--invert-x": 1,
            margin: `0 calc(-1*${maskWidth})`,
            padding: `calc(${maskHeight}/2) ${maskWidth}`,
            position: "relative", // for zIndex
            zIndex: -1, // should be underneath everything else
            overflow: "clip", // important so it doesn't affect page layout
            // Prefixed properties have better support than unprefixed ones:
            WebkitMaskImage: mask,
            WebkitMaskSize: maskSize,
            WebkitMaskPosition: "center, center, top left, top right, bottom right, bottom left",
            WebkitMaskRepeat: "no-repeat",
        }, children: children }));
}

function useIsInitialRender() {
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */
    const isInitialRender = React.useRef(true);
    React.useEffect(() => {
        isInitialRender.current = false;
    }, []);
    return isInitialRender.current;
}

function getWidthInEm(element) {
    const { width, fontSize } = getComputedStyle(element);
    return `${parseFloat(width) / parseFloat(fontSize)}em`;
}

const targetWidths = new WeakMap();

const NumberDigit = React.forwardRef(function NumberDigit({ value: _value, initialValue: _initialValue = _value, ...rest }, _ref) {
    const { transition } = React.useContext(react.MotionConfigContext);
    const initialValue = React.useRef(_initialValue).current; // non-reactive, like React's defaultValue props
    const isInitialRender = useIsInitialRender();
    const scope = React.useRef(null);
    const ref = React.useRef(null);
    React.useImperativeHandle(_ref, () => ref.current, []);
    const numberRefs = React.useRef(new Array(10));
    // Don't use a normal exit animation for this because we want it to trigger a resize:
    const isPresent = react.useIsPresent();
    const value = isPresent ? _value : 0;
    // Set the width to the width of the initial value immediately, so on the next render we animate from that:
    React.useLayoutEffect(() => {
        if (!scope.current || !numberRefs.current[initialValue])
            return;
        scope.current.style.width = getWidthInEm(numberRefs.current[initialValue]);
    }, []);
    // Animate the y in a layout effect, because it's a FLIP
    const prevValue = React.useRef(_initialValue);
    React.useLayoutEffect(() => {
        if (!scope.current || value === prevValue.current)
            return;
        const box = scope.current.getBoundingClientRect();
        const refBox = ref.current?.getBoundingClientRect();
        // Using a number seems to ensure Motion ends with "none", which we want:
        // Add the offset between the top of the inner and outer elements to account for
        // any current animation state:
        const initialY = box.height * (value - prevValue.current) +
            (box.top - (refBox ? refBox.top || 0 : box.top));
        react.animate(scope.current, { y: [initialY, 0] }, transition);
        return () => {
            prevValue.current = value;
        };
    }, [value]);
    const [width, setWidth] = React.useState();
    React.useEffect(() => {
        // Skip setting the width if this is the first render and it's not going to animate:
        if (isInitialRender && initialValue === value)
            return;
        if (!numberRefs.current[value])
            return;
        const w = getWidthInEm(numberRefs.current[value]);
        // Store the target width immediately, so it can be used for the section resize:
        if (ref.current)
            targetWidths.set(ref.current, w);
        // Trigger the actual layout animation by causing another render:
        setWidth(w);
    }, [value]);
    const renderNumber = (i) => (jsxRuntime.jsx("span", { style: {
            display: "inline-block",
            padding: `calc(${maskHeight}/2) 0`,
        }, ref: (r) => void (numberRefs.current[i] = r), children: i }, i));
    return (jsxRuntime.jsx(react.motion.span, { ...rest, ref: ref, layout: "position", "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: "center",
            width,
        }, children: jsxRuntime.jsxs("span", { ref: scope, style: {
                display: "inline-flex",
                justifyContent: "center",
                flexDirection: "column",
                alignItems: "center",
                position: "relative",
            }, children: [value !== 0 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        bottom: `100%`,
                        left: 0,
                    }, children: new Array(value)
                        .fill(null)
                        .map((_, i) => renderNumber(i)) })), renderNumber(value), value !== 9 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        top: `100%`,
                        left: 0,
                    }, children: new Array(9 - value)
                        .fill(null)
                        .map((_, i) => renderNumber(value + i + 1)) }))] }) }));
});
const digitFillStyle = {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    position: "absolute",
    width: "100%",
};

const SectionContext = React.createContext({
    justify: "left",
});

const NumberSymbol = React.forwardRef(function NumberSymbol({ partKey, type, children, layoutDependency, ...rest }, ref) {
    const isPresent = react.useIsPresent();
    const { justify } = React.useContext(SectionContext);
    return (jsxRuntime.jsx(react.motion.span, { ...rest, "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: justify,
            padding: `calc(${maskHeight}/2) 0`, // match digits
            position: "relative", // needed for AnimatePresent popLayout
        }, layout: "position", layoutDependency: layoutDependency, ref: ref, children: jsxRuntime.jsx(react.AnimatePresence, { mode: "popLayout", anchorX: justify, initial: false, children: jsxRuntime.jsx(react.motion.span, { layout: justify === "right" ? "position" : false, layoutDependency: layoutDependency, initial: { opacity: 0 }, animate: { opacity: [null, 1] }, exit: { opacity: [null, 0] }, style: {
                    display: "inline-block",
                    whiteSpace: "pre", // some symbols are spaces or thin spaces
                }, children: children }, children) }) }));
});

const NumberSection = React.forwardRef(function NumberSection({ parts, justify = "left", mode, style, name, layoutDependency, ...rest }, _ref) {
    const ref = React.useRef(null);
    React.useImperativeHandle(_ref, () => ref.current, []);
    const context = React.useMemo(() => ({ justify }), [justify]);
    const measuredRef = React.useRef(null);
    const isInitialRender = useIsInitialRender();
    // Keep a fixed width for the section, so that new characters get added to the end before the layout
    // animation starts, which makes them look like they were there already:
    const [width, setWidth] = React.useState();
    React.useEffect(() => {
        if (!measuredRef.current)
            return;
        if (isInitialRender) {
            if (ref.current)
                ref.current.style.width = getWidthInEm(measuredRef.current);
            return;
        }
        // Find the new width by removing exiting elements, measuring the measuredRef, and re-adding them
        // This better handles i.e. negative margins between elements.
        // We query the DOM because AnimatePresence overwrites ref props if the mode=popLayout
        const undos = Array.from(measuredRef.current.children).map((child) => {
            if (!(child instanceof HTMLElement))
                return;
            if (child.dataset.state === "exiting") {
                const next = child.nextSibling;
                child.remove();
                return () => {
                    // insertBefore() appends if next is null:
                    if (measuredRef.current) {
                        measuredRef.current.insertBefore(child, next);
                    }
                };
            }
            const newWidth = targetWidths.get(child);
            if (!newWidth)
                return;
            const oldWidth = child.style.width;
            child.style.width = newWidth;
            return () => {
                child.style.width = oldWidth;
            };
        });
        // Measure the resulting width:
        setWidth(getWidthInEm(measuredRef.current));
        // Then undo immediately:
        for (let i = undos.length - 1; i >= 0; i--) {
            const undo = undos[i];
            if (undo)
                undo();
        }
        // Trigger a parent render/layout:
    }, [parts.map((p) => p.value).join("")]);
    return (jsxRuntime.jsx(SectionContext.Provider, { value: context, children: jsxRuntime.jsx(react.motion.span, { layoutDependency: layoutDependency, ...rest, ref: ref, className: `number-section-${name}`, style: {
                ...style,
                display: "inline-flex",
                justifyContent: justify,
                width,
            }, children: jsxRuntime.jsxs("span", { ref: measuredRef, style: {
                    display: "inline-flex",
                    justifyContent: "inherit",
                    position: "relative", // needed for AnimatePresent popLayout
                }, children: ["\u200B", jsxRuntime.jsx(react.AnimatePresence, { mode: mode, anchorX: justify, initial: false, children: parts.map((part) => part.type === "integer" ||
                            part.type === "fraction" ? (jsxRuntime.jsx(NumberDigit, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, value: part.value, initialValue: isInitialRender ? undefined : 0, layoutDependency: layoutDependency }, part.key)) : (jsxRuntime.jsx(NumberSymbol, { type: part.type, partKey: part.key, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, layoutDependency: layoutDependency, children: part.value }, part.type === "literal"
                            ? `${part.key}:${part.value}`
                            : part.key))) })] }) }) }));
});

const formatToParts = (value, { locales, format, }, prefix, suffix) => {
    const formatter = new Intl.NumberFormat(locales, format);
    const parts = formatter.formatToParts(Number(value));
    if (prefix)
        parts.unshift({ type: "prefix", value: prefix });
    if (suffix)
        parts.push({ type: "suffix", value: suffix });
    const pre = [];
    const _integer = []; // we do a second pass to key these from RTL
    const fraction = [];
    const post = [];
    const counts = {};
    const generateKey = (type) => `${type}:${(counts[type] = (counts[type] ?? -1) + 1)}`;
    let formatted = "";
    let seenInteger = false, seenDecimal = false;
    for (const part of parts) {
        formatted += part.value;
        // Merge plus and minus sign types (doing it this way appeases TypeScript)
        const type = part.type === "minusSign" || part.type === "plusSign"
            ? "sign"
            : part.type;
        switch (type) {
            case "integer":
                seenInteger = true;
                _integer.push(...part.value
                    .split("")
                    .map((d) => ({ type, value: parseInt(d) })));
                break;
            case "group":
                _integer.push({ type, value: part.value });
                break;
            case "decimal":
                seenDecimal = true;
                fraction.push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
                break;
            case "fraction":
                fraction.push(...part.value.split("").map((d) => ({
                    type,
                    value: parseInt(d),
                    key: generateKey(type),
                })));
                break;
            // case 'nan':
            // case 'infinity':
            // 	// TODO: handle these
            // 	break
            // case 'exponentSeparator':
            // 	break
            // case 'exponentMinusSign':
            // case 'exponentInteger':
            // 	break
            default:
                (seenInteger || seenDecimal ? post : pre).push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
        }
    }
    const integer = [];
    // Key the integer parts RTL, for better layout animations
    for (let i = _integer.length - 1; i >= 0; i--) {
        integer.unshift({
            ..._integer[i],
            key: generateKey(_integer[i].type),
        });
    }
    return { pre, integer, fraction, post, formatted };
};

const DEFAULT_TRANSITION = {
    // We use keyframes and times so the opacity/exit animations can last
    // as long as the layout animation, so Framer Motion doesn't have to
    // remove exiting elements until the layout animation is done.
    // This worked better in testing than safeToRemove() from usePresence()
    opacity: { duration: 1, ease: react.easeOut }, // perceptual duration of 0.5s
    layout: { type: "spring", duration: 1, bounce: 0 },
    y: { type: "spring", duration: 1, bounce: 0 },
};
const AnimateNumber = React.forwardRef(function AnimateNumber({ children: value, locales, format, transition, style, suffix, prefix, ...rest }, ref) {
    // Split the number into parts
    const parts = React.useMemo(() => formatToParts(value, { locales, format }, prefix, suffix), [value, locales, format]);
    const { pre, integer, fraction, post, formatted } = parts;
    const contextTransition = React.useContext(react.MotionConfigContext).transition;
    transition = transition ?? contextTransition ?? DEFAULT_TRANSITION;
    const { layoutDependency } = rest;
    const dependency = React.useMemo(() => {
        if (layoutDependency === undefined)
            return undefined;
        return { layoutDependency, value };
    }, [layoutDependency, value]);
    return (jsxRuntime.jsx(react.LayoutGroup, { children: jsxRuntime.jsx(react.MotionConfig, { transition: transition, children: jsxRuntime.jsx(react.motion.div, { ...rest, ref: ref, layout // For convenience, b/c it's basically implied
                : true, layoutDependency: dependency, style: {
                    lineHeight: 1, // make this one easy to override
                    ...style,
                    display: "inline-flex",
                    isolation: "isolate", // so number can be underneath first/last
                    whiteSpace: "nowrap",
                }, children: jsxRuntime.jsxs(react.motion.div, { layout: true, layoutDependency: dependency, "aria-label": formatted, style: {
                        display: "inline-flex",
                        direction: "ltr", // I think this is needed b/c numbers are always LTR?
                        isolation: "isolate", // so number can be underneath pre/post
                        position: "relative",
                        zIndex: -1, // so the whole number is under any first/last
                        // userSelect: "none", // I think adding this to the parent then undoing it on the selectable one might work a little better
                        // pointerEvents: "none",
                    }, children: [jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, layoutDependency: dependency, "aria-hidden": true, justify: "right", mode: "popLayout", parts: pre, name: "pre" }), jsxRuntime.jsxs(Mask, { layoutDependency: dependency, children: [jsxRuntime.jsx(NumberSection, { layoutDependency: dependency, justify: "right", parts: integer, name: "integer" }), jsxRuntime.jsx(NumberSection, { layout: "position", layoutDependency: dependency, parts: fraction, name: "fraction" })] }), jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, "aria-hidden": true, layout: "position", layoutDependency: dependency, mode: "popLayout", parts: post, name: "post" })] }) }) }) }));
});

const MotionFragment = react.motion.create(React__namespace.Fragment);
function splitText(text, { splitBy = " ", charClass = "split-char", wordClass = "split-word", variants, type, } = {}) {
    const words = text.split(splitBy);
    const elements = [];
    const delimiter = splitBy === " " ? "\u00A0" : splitBy;
    for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
        const word = words[wordIndex];
        const characterElements = [];
        const chars = Array.from(word);
        for (let charIndex = 0; charIndex < chars.length; charIndex++) {
            let char = chars[charIndex];
            if (wordIndex < words.length - 1 &&
                charIndex === chars.length - 1) {
                char += delimiter;
            }
            const Component = type === "char" ? react.motion.span : "span";
            characterElements.push(jsxRuntime.jsx(Component, { className: `${charClass} ${charClass}-${charIndex + 1}`, style: { display: "inline-block" }, ...(type === "char" ? { variants } : {}), children: char }, `${wordIndex}-${charIndex}`));
        }
        const WordComponent = type === "word" ? react.motion.span : "span";
        elements.push(jsxRuntime.jsx(WordComponent, { className: `${wordClass} ${wordClass}-${wordIndex + 1}`, style: { display: "inline-block" }, ...(type === "word" ? { variants } : {}), children: characterElements }, `word-${wordIndex}`));
    }
    return elements;
}
function AnimateText({ children, splitBy = " ", charClass = "split-char", wordClass = "split-word", lineClass = "split-line", type = "char", variants, ...props }) {
    const elements = React.useMemo(() => {
        return splitText(children, {
            splitBy,
            charClass,
            wordClass,
            variants,
            type,
        });
    }, [children, splitBy, charClass, wordClass]);
    return jsxRuntime.jsx(MotionFragment, { ...props, children: elements });
}

exports.AnimateNumber = AnimateNumber;
exports.AnimateText = AnimateText;
exports.Cursor = Cursor;
exports.useCursorIsInView = useCursorIsInView;
exports.useCursorState = useCursorState;
exports.usePointerPosition = usePointerPosition;
