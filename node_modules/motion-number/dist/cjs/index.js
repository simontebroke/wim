'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var react = require('motion/react');
var react$1 = require('react');

const formatToParts = (value, { locales, format, }, prefix, suffix) => {
    const formatter = new Intl.NumberFormat(locales, format);
    const parts = formatter.formatToParts(Number(value));
    if (prefix)
        parts.unshift({ type: "prefix", value: prefix });
    if (suffix)
        parts.push({ type: "suffix", value: suffix });
    const pre = [];
    const _integer = []; // we do a second pass to key these from RTL
    const fraction = [];
    const post = [];
    const counts = {};
    const generateKey = (type) => `${type}:${(counts[type] = (counts[type] ?? -1) + 1)}`;
    let formatted = "";
    let seenInteger = false, seenDecimal = false;
    for (const part of parts) {
        formatted += part.value;
        // Merge plus and minus sign types (doing it this way appeases TypeScript)
        const type = part.type === "minusSign" || part.type === "plusSign"
            ? "sign"
            : part.type;
        switch (type) {
            case "integer":
                seenInteger = true;
                _integer.push(...part.value
                    .split("")
                    .map((d) => ({ type, value: parseInt(d) })));
                break;
            case "group":
                _integer.push({ type, value: part.value });
                break;
            case "decimal":
                seenDecimal = true;
                fraction.push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
                break;
            case "fraction":
                fraction.push(...part.value.split("").map((d) => ({
                    type,
                    value: parseInt(d),
                    key: generateKey(type),
                })));
                break;
            // case 'nan':
            // case 'infinity':
            // 	// TODO: handle these
            // 	break
            // case 'exponentSeparator':
            // 	break
            // case 'exponentMinusSign':
            // case 'exponentInteger':
            // 	break
            default:
                (seenInteger || seenDecimal ? post : pre).push({
                    type,
                    value: part.value,
                    key: generateKey(type),
                });
        }
    }
    const integer = [];
    // Key the integer parts RTL, for better layout animations
    for (let i = _integer.length - 1; i >= 0; i--) {
        integer.unshift({
            ..._integer[i],
            key: generateKey(_integer[i].type),
        });
    }
    return { pre, integer, fraction, post, formatted };
};

// Build the mask for the numbers. Technique taken from:
// https://expensive.toys/blog/blur-vignette
const maskHeight = "var(--mask-height, 0.15em)";
const maskWidth = "var(--mask-width, 0.5em)";
const correctedMaskWidth = `calc(${maskWidth} / var(--invert-x, 1))`;
const cornerGradient = `#000 0, transparent 71%`; // or transparent ${maskWidth}
const mask = 
// Horizontal:
`linear-gradient(to right, transparent 0, #000 ${correctedMaskWidth}, #000 calc(100% - ${correctedMaskWidth}), transparent),` +
    // Vertical:
    `linear-gradient(to bottom, transparent 0, #000 ${maskHeight}, #000 calc(100% - ${maskHeight}), transparent 100%),` +
    // TL corner
    `radial-gradient(at bottom right, ${cornerGradient}),` +
    // TR corner
    `radial-gradient(at bottom left, ${cornerGradient}), ` +
    // BR corner
    `radial-gradient(at top left, ${cornerGradient}), ` +
    // BL corner
    `radial-gradient(at top right, ${cornerGradient})`;
const maskSize = `100% calc(100% - ${maskHeight} * 2),` +
    `calc(100% - ${correctedMaskWidth} * 2) 100%,` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight},` +
    `${correctedMaskWidth} ${maskHeight}`;
react.addScaleCorrector({
    "--invert-x": {
        correct: (_, { treeScale, projectionDelta }) => projectionDelta.x.scale * treeScale.x,
    },
});
function Mask({ children }) {
    return (jsxRuntime.jsx(react.motion.span, { layout: true, "aria-hidden": true, style: {
            display: "inline-flex",
            // Activates the scale correction, which gets stored in --invert-xion
            "--invert-x": 1,
            margin: `0 calc(-1*${maskWidth})`,
            padding: `calc(${maskHeight}/2) ${maskWidth}`,
            position: "relative", // for zIndex
            zIndex: -1, // should be underneath everything else
            overflow: "clip", // important so it doesn't affect page layout
            // Prefixed properties have better support than unprefixed ones:
            WebkitMaskImage: mask,
            WebkitMaskSize: maskSize,
            WebkitMaskPosition: "center, center, top left, top right, bottom right, bottom left",
            WebkitMaskRepeat: "no-repeat",
        }, children: children }));
}

function useIsInitialRender() {
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */
    const isInitialRender = react$1.useRef(true);
    react$1.useEffect(() => {
        isInitialRender.current = false;
    }, []);
    return isInitialRender.current;
}

function getWidthInEm(element) {
    const { width, fontSize } = getComputedStyle(element);
    return `${parseFloat(width) / parseFloat(fontSize)}em`;
}

const targetWidths = new WeakMap();

const NumberDigit = react$1.forwardRef(function NumberDigit({ value: _value, initialValue: _initialValue = _value, ...rest }, _ref) {
    const { transition } = react$1.useContext(react.MotionConfigContext);
    const initialValue = react$1.useRef(_initialValue).current; // non-reactive, like React's defaultValue props
    const isInitialRender = useIsInitialRender();
    const scope = react$1.useRef(null);
    const ref = react$1.useRef(null);
    react$1.useImperativeHandle(_ref, () => ref.current, []);
    const numberRefs = react$1.useRef(new Array(10));
    // Don't use a normal exit animation for this because we want it to trigger a resize:
    const isPresent = react.useIsPresent();
    const value = isPresent ? _value : 0;
    // Set the width to the width of the initial value immediately, so on the next render we animate from that:
    react$1.useLayoutEffect(() => {
        if (!scope.current || !numberRefs.current[initialValue])
            return;
        scope.current.style.width = getWidthInEm(numberRefs.current[initialValue]);
    }, []);
    // Animate the y in a layout effect, because it's a FLIP
    const prevValue = react$1.useRef(_initialValue);
    react$1.useLayoutEffect(() => {
        if (!scope.current || value === prevValue.current)
            return;
        const box = scope.current.getBoundingClientRect();
        const refBox = ref.current?.getBoundingClientRect();
        // Using a number seems to ensure Motion ends with "none", which we want:
        // Add the offset between the top of the inner and outer elements to account for
        // any current animation state:
        const initialY = box.height * (value - prevValue.current) +
            (box.top - (refBox ? refBox.top || 0 : box.top));
        react.animate(scope.current, { y: [initialY, 0] }, transition);
        return () => {
            prevValue.current = value;
        };
    }, [value]);
    const [width, setWidth] = react$1.useState();
    react$1.useEffect(() => {
        // Skip setting the width if this is the first render and it's not going to animate:
        if (isInitialRender && initialValue === value)
            return;
        if (!numberRefs.current[value])
            return;
        const w = getWidthInEm(numberRefs.current[value]);
        // Store the target width immediately, so it can be used for the section resize:
        if (ref.current)
            targetWidths.set(ref.current, w);
        // Trigger the actual layout animation by causing another render:
        setWidth(w);
    }, [value]);
    const renderNumber = (i) => (jsxRuntime.jsx("span", { style: {
            display: "inline-block",
            padding: `calc(${maskHeight}/2) 0`,
        }, ref: (r) => void (numberRefs.current[i] = r), children: i }, i));
    return (jsxRuntime.jsx(react.motion.span, { ...rest, ref: ref, layout: "position", "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: "center",
            width,
        }, children: jsxRuntime.jsxs("span", { ref: scope, style: {
                display: "inline-flex",
                justifyContent: "center",
                flexDirection: "column",
                alignItems: "center",
                position: "relative",
            }, children: [value !== 0 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        bottom: `100%`,
                        left: 0,
                    }, children: new Array(value)
                        .fill(null)
                        .map((_, i) => renderNumber(i)) })), renderNumber(value), value !== 9 && (jsxRuntime.jsx("span", { style: {
                        ...digitFillStyle,
                        top: `100%`,
                        left: 0,
                    }, children: new Array(9 - value)
                        .fill(null)
                        .map((_, i) => renderNumber(value + i + 1)) }))] }) }));
});
const digitFillStyle = {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    position: "absolute",
    width: "100%",
};

const SectionContext = react$1.createContext({
    justify: "left",
});

const NumberSymbol = react$1.forwardRef(function NumberSymbol({ partKey, type, children, ...rest }, ref) {
    const isPresent = react.useIsPresent();
    const { justify } = react$1.useContext(SectionContext);
    return (jsxRuntime.jsx(react.motion.span, { ...rest, "data-state": isPresent ? undefined : "exiting", style: {
            display: "inline-flex",
            justifyContent: justify,
            padding: `calc(${maskHeight}/2) 0`, // match digits
            position: "relative", // needed for AnimatePresent popLayout
        }, layout: "position", ref: ref, children: jsxRuntime.jsx(react.AnimatePresence, { mode: "popLayout", anchorX: justify, initial: false, children: jsxRuntime.jsx(react.motion.span, { layout: justify === "right" ? "position" : false, initial: { opacity: 0 }, animate: { opacity: [null, 1] }, exit: { opacity: [null, 0] }, style: {
                    display: "inline-block",
                    whiteSpace: "pre", // some symbols are spaces or thin spaces
                }, children: children }, children) }) }));
});

const NumberSection = react$1.forwardRef(function NumberSection({ parts, justify = "left", mode, style, name, ...rest }, _ref) {
    const ref = react$1.useRef(null);
    react$1.useImperativeHandle(_ref, () => ref.current, []);
    const context = react$1.useMemo(() => ({ justify }), [justify]);
    const measuredRef = react$1.useRef(null);
    const isInitialRender = useIsInitialRender();
    // Keep a fixed width for the section, so that new characters get added to the end before the layout
    // animation starts, which makes them look like they were there already:
    const [width, setWidth] = react$1.useState();
    react$1.useEffect(() => {
        if (!measuredRef.current)
            return;
        if (isInitialRender) {
            if (ref.current)
                ref.current.style.width = getWidthInEm(measuredRef.current);
            return;
        }
        // Find the new width by removing exiting elements, measuring the measuredRef, and re-adding them
        // This better handles i.e. negative margins between elements.
        // We query the DOM because AnimatePresence overwrites ref props if the mode=popLayout
        const undos = Array.from(measuredRef.current.children).map((child) => {
            if (!(child instanceof HTMLElement))
                return;
            if (child.dataset.state === "exiting") {
                const next = child.nextSibling;
                child.remove();
                return () => {
                    // insertBefore() appends if next is null:
                    if (measuredRef.current) {
                        measuredRef.current.insertBefore(child, next);
                    }
                };
            }
            const newWidth = targetWidths.get(child);
            if (!newWidth)
                return;
            const oldWidth = child.style.width;
            child.style.width = newWidth;
            return () => {
                child.style.width = oldWidth;
            };
        });
        // Measure the resulting width:
        setWidth(getWidthInEm(measuredRef.current));
        // Then undo immediately:
        for (let i = undos.length - 1; i >= 0; i--) {
            const undo = undos[i];
            if (undo)
                undo();
        }
        // Trigger a parent render/layout:
    }, [parts.map((p) => p.value).join("")]);
    return (jsxRuntime.jsx(SectionContext.Provider, { value: context, children: jsxRuntime.jsx(react.motion.span, { ...rest, ref: ref, className: `number-section-${name}`, style: {
                ...style,
                display: "inline-flex",
                justifyContent: justify,
                width,
            }, children: jsxRuntime.jsxs("span", { ref: measuredRef, style: {
                    display: "inline-flex",
                    justifyContent: "inherit",
                    position: "relative", // needed for AnimatePresent popLayout
                }, children: ["\u200B", jsxRuntime.jsx(react.AnimatePresence, { mode: mode, anchorX: justify, initial: false, children: parts.map((part) => part.type === "integer" ||
                            part.type === "fraction" ? (jsxRuntime.jsx(NumberDigit, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, value: part.value, initialValue: isInitialRender ? undefined : 0 }, part.key)) : (jsxRuntime.jsx(NumberSymbol, { type: part.type, partKey: part.key, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: part.value }, part.type === "literal"
                            ? `${part.key}:${part.value}`
                            : part.key))) })] }) }) }));
});

const DEFAULT_TRANSITION = {
    // We use keyframes and times so the opacity/exit animations can last
    // as long as the layout animation, so Framer Motion doesn't have to
    // remove exiting elements until the layout animation is done.
    // This worked better in testing than safeToRemove() from usePresence()
    opacity: { duration: 1, ease: react.easeOut }, // perceptual duration of 0.5s
    layout: { type: "spring", duration: 1, bounce: 0 },
    y: { type: "spring", duration: 1, bounce: 0 },
};
const AnimateNumber = react$1.forwardRef(function AnimateNumber({ children: value, locales, format, transition, style, suffix, prefix, ...rest }, ref) {
    // Split the number into parts
    const parts = react$1.useMemo(() => formatToParts(value, { locales, format }, prefix, suffix), [value, locales, format]);
    const { pre, integer, fraction, post, formatted } = parts;
    const contextTransition = react$1.useContext(react.MotionConfigContext).transition;
    transition = transition ?? contextTransition ?? DEFAULT_TRANSITION;
    return (jsxRuntime.jsx(react.LayoutGroup, { children: jsxRuntime.jsx(react.MotionConfig, { transition: transition, children: jsxRuntime.jsx(react.motion.div, { ...rest, ref: ref, layout // For convenience, b/c it's basically implied
                : true, style: {
                    lineHeight: 1, // make this one easy to override
                    ...style,
                    display: "inline-flex",
                    isolation: "isolate", // so number can be underneath first/last
                    whiteSpace: "nowrap",
                }, children: jsxRuntime.jsxs(react.motion.div, { layout: true, "aria-label": formatted, style: {
                        display: "inline-flex",
                        direction: "ltr", // I think this is needed b/c numbers are always LTR?
                        isolation: "isolate", // so number can be underneath pre/post
                        position: "relative",
                        zIndex: -1, // so the whole number is under any first/last
                        // userSelect: "none", // I think adding this to the parent then undoing it on the selectable one might work a little better
                        // pointerEvents: "none",
                    }, children: [jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, "aria-hidden": true, justify: "right", mode: "popLayout", parts: pre, name: "pre" }), jsxRuntime.jsxs(Mask, { children: [jsxRuntime.jsx(NumberSection, { justify: "right", parts: integer, name: "integer" }), jsxRuntime.jsx(NumberSection, { layout: "position", parts: fraction, name: "fraction" })] }), jsxRuntime.jsx(NumberSection, { style: { padding: `calc(${maskHeight}/2) 0` }, "aria-hidden": true, layout: "position", mode: "popLayout", parts: post, name: "post" })] }) }) }) }));
});

exports.AnimateNumber = AnimateNumber;
